<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="welcome to wxt's blog!"><title>多线程 | wxt's blog！</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">多线程</h1><a id="logo" href="/blog/.">wxt's blog！</a><p class="description"></p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">多线程</h1><div class="post-meta">Aug 7, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程：<br><strong>&emsp;1、进程和线程：</strong><br>&emsp;&emsp;进程：正在进行的程序。每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。<br>&emsp;&emsp;线程：进程内部的一条执行路径或者一个控制单元。<br>&emsp;&emsp;两者的区别：<br>&emsp;&emsp;&emsp;一个进程至少有一个线程<br>&emsp;&emsp;进程在执行过程中拥有独立的内存单元，而多个线程共享内存；</p>
<p><strong>&emsp;2、jvm多线程的启动是多线程吗？</strong><br>&emsp;&emsp;java的虚拟机jvm启动的是单线程，就有发生内存泄露的可能，而我们使用java程序没出现这样的问题，<br>&emsp;&emsp;也就是jvm启动至少有两个线程，一个执行java程序，一个执行垃圾回收。所以是多线程。</p>
<p><strong>&emsp;3、多线程的优势：</strong><br>&emsp;&emsp;解决了多部分同时运行的问题，提高效率</p>
<p><strong>&emsp;4、线程的弊端：</strong><br>&emsp;&emsp;线程太多会导致效率的降低，因为线程的执行依靠的是CPU的来回切换。</p>
<p><strong>&emsp;5、什么叫多线程：</strong><br>&emsp;&emsp;一个进程中有多个线程，称为多线程。</p>
<p><strong>&emsp;6、实现多线程的方法：</strong><br>&emsp;&emsp;实现多线程可以通过继承Thread类和实现Runnable接口。</p>
<p><strong>(1)继承Thread</strong></p>
<blockquote>
<p>定义一个类继承Thread类<br>   复写Thread类中的public void run()方法，将线程的任务代码封装到run方法中<br>   直接创建Thread的子类对象，创建线程<br>   调用start()方法，开启线程(调用线程的任务run方法)<br>   //另外可以通过Thread的getName()获取线程的名称。</p>
</blockquote>
<p><strong>(2)实现Runnable接口；</strong></p>
<blockquote>
<p>定义一个类，实现Runnable接口；<br>覆盖接口的public void run()的方法，将线程的任务代码封装到run方法中；<br>创建Runnable接口的子类对象<br>将Runnabl接口的子类对象作为参数传递给Thread类的构造函数，创建Thread类对象<br>                       （原因：线程的任务都封装在Runnable接口子类对象的run方法中。<br>        所以要在线程对象创建时就必须明确要运行的任务）。<br>调用start()方法，启动线程。</p>
</blockquote>
<p>两种方法区别：</p>
<ul>
<li>(1)实现Runnable接口避免了单继承的局限性</li>
<li>(2)继承Thread类线程代码存放在Thread子类的run方法中<br>&emsp;实现Runnable接口线程代码存放在接口的子类的run方法中；<br>&emsp; 在定义线程时，建议使用实现Runnable接口，因为几乎所有多线程都可以使用这种方式实现</li>
</ul>
<p>6、创建线程是为什么要复写run方法？</p>
<blockquote>
<p>Thread类用于描述线程。Thread类定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。</p>
</blockquote>
<p>7、start()和run方法有什么区别？</p>
<blockquote>
<p>调用start方法方可启动线程，而run方法只是thread的一个普通方法，调用run方法不能实现多线程；<br>Start()方法:<br>start方法用来启动线程,实现了多线程运行,这时无需等待run方法体代码执行完毕而直接继续执行下面的<br>代码。通过调用Thread类的start()方法来启动一个线程,这时此线程处于就绪(可运行)状态，并没有运行，<br>一旦得到cpu时间片(执行权),就开始执行run()方法,这里方法run()称为线程体，<br>它包含了要执行的这个线程的内容，Run方法运行结束,此线程随即终止。<br>Run()方法:<br>run()方法只是Thread类的一个普通方法,如果直接调用Run方法,程序中依然只有主线程这一个线程,<br>其程序执行路径还是只有一条，还是要等待run方法体执行完毕后才可继续执行下面的代码，<br>这样就没有达到多线程的目的。</p>
</blockquote>
<p>8、线程的几种状态：</p>
<blockquote>
<p>新建：new一个Thread对象或者其子类对象就是创建一个线程，当一个线程对象被创建，但是没有开启，这个时候，<br>     只是对象线程对象开辟了内存空间和初始化数据。<br>就绪：新建的对象调用start方法，就开启了线程，线程就到了就绪状态。<br>     在这个状态的线程对象，具有执行资格，没有执行权。<br>运行：当线程对象获取到了CPU的资源。<br>     在这个状态的线程对象，既有执行资格，也有执行权。<br>冻结：运行过程中的线程由于某些原因(比如wait,sleep)，释放了执行资格和执行权。<br>              当然，他们可以回到运行状态。只不过，不是直接回到。<br>     而是先回到就绪状态。<br>死亡：当线程对象调用的run方法结束，或者直接调用stop方法，就让线程对象死亡，在内存中变成了垃圾。</p>
</blockquote>
<p>9、sleep()和wait()的区别：</p>
<blockquote>
<p>(1)这两个方法来自不同的类，sleep()来自Thread类，和wait()来自Object类。<br>(2)sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，<br>   要让b线程睡觉要在b的代码中调用sleep。而wait()是Object类的非静态方法<br>(3)sleep()释放资源不释放锁，而wait()释放资源释放锁；<br>(4)使用范围：wait,notify和notifyAll只能在同步控制方法或者同步控制块里面使用,而sleep可以在任何地方使用</p>
</blockquote>
<p>10、多线程安全问题：</p>
<blockquote>
<p>(1)原因:当程序的多条语句在操作线程共享数据时(如买票例子中的票就是共享资源)，由于线程的随机性导致<br>       一个线程对多条语句，执行了一部分还没执行完，另一个线程抢夺到cpu执行权参与进来执行，<br>       此时就导致共享数据发生错误。比如买票例子中打印重票和错票的情况。<br>(2)解决方法:对多条操作共享数据的语句进行同步，一个线程在执行过程中其他线程不可以参与进来</p>
</blockquote>
<p>11、Java中多线程同步是什么？</p>
<blockquote>
<p>同步是用来解决多线程的安全问题的，在多线程中，同步能控制对共享数据的访问。如果没有同步，当一个线程在<br>修改一个共享数据时，而另外一个线程正在使用或者更新同一个共享数据，这样容易导致程序出现错误的结果。</p>
</blockquote>
<p>12、什么是锁?锁的作用是什么?</p>
<blockquote>
<p>锁就是对象<br>锁的作用是保证线程同步，解决线程安全问题。<br>持有锁的线程可以在同步中执行，没有锁的线程即使获得cpu执行权，也进不去。</p>
</blockquote>
<p>13、同步的前提:</p>
<blockquote>
<p>(1)必须保证有两个以上线程<br>(2)必须是多个线程使用同一个锁，即多条语句在操作线程共享数据<br>(3)必须保证同步中只有一个线程在运行</p>
</blockquote>
<p>14、同步的好处和弊端</p>
<blockquote>
<p>好处：同步解决了多线程的安全问题<br>弊端：多线程都需要判断锁，比较消耗资源</p>
</blockquote>
<p>15、同步的两种表现形式：</p>
<blockquote>
<p>(1)同步代码块:<br>可以指定需要获取哪个对象的同步锁,使用synchronized的代码块同样需要锁,但他的锁可以是任意对象<br>考虑到安全问题，一般还是使用同一个对象，相对来说效率较高。</p>
</blockquote>
<p>注意：</p>
<ol>
<li>虽然同步代码快的锁可以使任何对象，但是在进行多线程通信使用同步代码快时，</li>
<li>必须保证同步代码快的锁的对象和，否则会报错。</li>
<li>同步函数的锁是this，也要保证同步函数的锁的对象和调用wait、notify和notifyAll的对象是</li>
<li>同一个对象，也就是都是this锁代表的对象。<br>格式：<blockquote>
<p>synchronized(对象)<br>{<br>需同步的代码;<br>}</p>
</blockquote>
</li>
</ol>
<p>(2)同步函数</p>
<ol>
<li>同步方法是指进入该方法时需要获取this对象的同步锁，在方法上使用synchronized关键字，</li>
<li>使用this对象作为锁，也就是使用了当前对象，因为锁住了方法，所以相对于代码块来说效率相对较低。<br>注:静态同步函数的锁是该方法所在的类的字节码文件对象，即类名.class文件<br>格式：<blockquote>
<p>修饰词 synchronized 返回值类型 函数名(参数列表)<br>{<br>需同步的代码;<br>}</p>
</blockquote>
</li>
</ol>
<ol>
<li>在jdk1.5后，用lock锁取代了synchronized，个人理解也就是对同步代码块做了修改，</li>
<li>并没有提供对同步方法的修改，主要还是效率问题吧。</li>
<li>多线程的单例设计模式：保证某个类中内存中只有一个对象<br>(1)饿汉式:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//将构造函数私有化，不让别的类建立该类对象</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single s=<span class="keyword">new</span> Single();<span class="comment">//自己建立一个对象</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span><span class="comment">//提供一个公共访问方式</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>(2)懒汉式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single s;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(s==<span class="keyword">null</span>)</div><div class="line">		s=<span class="keyword">new</span> Single();</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>饿汉式和懒汉式的区别：</strong></p>
<ul>
<li>饿汉式是类一加载进内存就创建好了对象；</li>
<li>懒汉式则是类加载进内存的时候，对象还没有存在，只有调用了getInstance()方法时，对象才开始创建。</li>
<li>懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题</li>
<li>可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，</li>
<li>所以可以加双重判断来提高程序效率。</li>
</ul>
<p>如将上述懒汉式的Instance函数改成同步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(s==<span class="keyword">null</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">synchronized</span>(Single.class)</div><div class="line">	&#123;</div><div class="line">	<span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">		s=<span class="keyword">new</span> Single();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>17、死锁</strong><br>两个线程对两个同步对象具有循环依赖时，就会发生死锁。即同步嵌套同步，而锁却不同。</p>
<p><strong>18、wait()、sleep()、notify()、notifyAll()</strong></p>
<blockquote>
<p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，<br>而是由JVM确定唤醒哪个线程(一般是最先开始等待的线程)，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
</blockquote>
<p>1.为什么wait()、notify()、notifyAll()这些用来操作线程的方法定义在Object类中？<br>(1)这些方法只存在于同步中；<br>(2)使用这些方法时必须要指定所属的锁，即被哪个锁调用这些方法；<br>(3)而锁可以是任意对象，所以任意对象调用的方法就定义在Object中。</p>
<p><strong>19、多线程间通讯：</strong><br>  多线程间通讯就是多个线程在操作同一资源,但是操作的动作不同.<br>    (1)为什么要通信</p>
<pre><code>1. 多线程并发执行的时候, 如果需要指定线程等待或者唤醒指定线程, 那么就需要通信.比如生产者消费者的问题，
2. 生产一个消费一个,生产的时候需要负责消费的进程等待,生产一个后完成后需要唤醒负责消费的线程,
3. 同时让自己处于等待，消费的时候负责消费的线程被唤醒，消费完生产的产品后又将等待的生产线程唤醒，
4. 然后使自己线程处于等待。这样来回通信，以达到生产一个消费一个的目的。
</code></pre><p>  (2)怎么通信</p>
<pre><code>1. 在同步代码块中, 使用锁对象的wait()方法可以让当前线程等待, 直到有其他线程唤醒为止.
2. 使用锁对象的notify()方法可以唤醒一个等待的线程，或者notifyAll唤醒所有等待的线程.
3. 多线程间通信用sleep很难实现，睡眠时间很难把握。
</code></pre><p><strong>20、Lock和Condition</strong></p>
<ol>
<li>实现提供比synchronized方法和语句可获得的更广泛的锁的操作，可支持多个相关的Condition对象</li>
<li>Lock是个接口</li>
<li>锁是控制多个线程对共享数据进行访问的工具。</li>
</ol>
<p><strong>JDK1.5中提供了多线程升级的解决方案：</strong></p>
<blockquote>
<p>将同步synchonized替换成了显示的Lock操作，将Object中的wait、notify、notifyAll替换成了Condition对象。<br>该对象可以Lock锁进行获取</p>
</blockquote>
<p><strong>Lock的方法摘要：</strong></p>
<blockquote>
<p>void lock()  获取锁。<br>Condition newCondition() 返回绑定到此 Lock 实例的新 Condition 实例。<br>void unlock() 释放锁。<br>Condition方法摘要：<br>void await() 造成当前线程在接到信号或被中断之前一直处于等待状态。<br>void signal() 唤醒一个等待线程。<br>void signalAll() 唤醒所有等待线程。</p>
</blockquote>
<p><strong>21、停止线程：</strong></p>
<blockquote>
<p>stop方法已经过时，如何停止线程？<br>停止线程的方法只有一种，就是run方法结束。如何让run方法结束呢？<br>开启多线程运行，运行代码通常是循环体，只要控制住循环，就可以让run方法结束，也就是结束线程。</p>
</blockquote>
<p>⚠️ 特殊情况：当线程属于冻结状态，就不会读取循环控制标记，则线程就不会结束。<br>为解决该特殊情况，可引入Thread类中的Interrupt方法结束线程的冻结状态；<br>当没有指定的方式让冻结线程恢复到运行状态时，需要对冻结进行清除，强制让线程恢复到运行状态</p>
<p><strong>22、interrupt:</strong></p>
<blockquote>
<p>void interrupt() 中断线程:<br>中断状态将被清除，它还将收到一个 InterruptedException</p>
</blockquote>
<p><strong>22、守护线程(后台线程)</strong></p>
<blockquote>
<p>setDaemon(boolean on):将该线程标记为守护线程或者用户线程。<br>当主线程结束，守护线程自动结束，比如圣斗士星矢里面的守护雅典娜，<br>在多线程里面主线程就是雅典娜，守护线程就是圣斗士，主线程结束了，<br>守护线程则自动结束。<br>当正在运行的线程都是守护线程时，java虚拟机jvm退出；所以该方法必须在启动线程前调用；</p>
<blockquote>
<p><strong>守护线程的特点：</strong><br>守护线程开启后和前台线程共同抢夺cpu的执行权，开启、运行两者都没区别，<br>但结束时有区别，当所有前台线程都结束后，守护线程会自动结束。<br>23、多线程join方法：<br>void join() 等待该线程终止。<br>void join(long millis)  等待该线程终止的时间最长为 millis 毫秒。<br>throws InterruptedException<br>特点：当A线程执行到B线程的join方法时，A就会等待B线程都执行完，A才会执行<br>作用: join可以用来临时加入线程执行；<br>24、多线程优先级：yield()方法<br>yield():暂停当前正在执行的线程对象，并执行其他线程<br>setPriority(int newPriority):更改线程优先级<br>int getPriority() 返回线程的优先级。<br>String toString() 返回该线程的字符串表示形式，包括线程名称、优先级和线程组</p>
</blockquote>
</blockquote>
<p>(1)MAX_PRIORITY:最高优先级(10级)<br>(1)Min_PRIORITY:最低优先级(1级)<br>(1)Morm_PRIORITY:默认优先级(5级)</p>
<p><strong><br>25、什么是ThreadLocal类,怎么使用它？</strong></p>
<blockquote>
<p>ThreadLocal类提供了线程局部 (thread-local) 变量。是一个线程级别的局部变量，并非“本地线程”。<br>ThreadLocal 为每个使用该变量的线程,提供了一个独立的变量副本，每个线程修改副本时不影响其它线程对象的副本</p>
<blockquote>
<p>下面是线程局部变量(ThreadLocal variables)的关键点：<br>一个线程局部变量(ThreadLocal variables)为每个线程方便地提供了一个单独的变量。<br>ThreadLocal 实例通常作为静态的私有的(private static)字段出现在一个类中，这个类用来关联一个线程。<br>当多个线程访问 ThreadLocal 实例时，每个线程维护 ThreadLocal 提供的独立的变量副本。<br>常用的使用可在 DAO 模式中见到，当 DAO 类作为一个单例类时，<br>数据库链接(connection)被每一个线程独立的维护，互不影响。(基于线程的单例)</p>
</blockquote>
</blockquote>
<p>26、什么时候抛出InvalidMonitorStateException异常?为什么？</p>
<blockquote>
<p>调用 wait ()/notify ()/notifyAll ()中的任何一个方法时，如果当前线程没有获得该对象的锁，<br>那么就会抛出 IllegalMonitorStateException 的异常<br>也就是说程序在没有执行对象的任何同步块或者同步方法时，<br>仍然尝试调用 wait ()/notify ()/notifyAll ()时。由于该异常是 RuntimeExcpetion 的子类，<br>所以该异常不一定要捕获(尽管你可以捕获只要你愿意<br>作为 RuntimeException，此类异常不会在 wait (),notify (),notifyAll ()的方法签名提及。</p>
</blockquote>
<p>27、在静态方法上使用同步时会发生什么事？</p>
<blockquote>
<p>同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，<br>线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。<br>它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。</p>
</blockquote>
<p>28、当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？</p>
<blockquote>
<p>可以，一个非同步方法总是可以被调用而不会有任何问题。<br>实际上，Java 没有为非同步方法做任何检查，锁对象仅仅在同步方法或者同步代码块中检查。<br>如果一个方法没有声明为同步，即使你在使用共享数据Java照样会调用，而不会做检查是否安全，<br>所以在这种情况下要特别小心。一个方法是否声明为同步取决于临界区访问(critial section access)，<br>如果方法不访问临界区(共享资源或者数据结构)就没必要声明为同步的。</p>
</blockquote>
<p>29、在一个对象上两个线程可以调用两个不同的同步实例方法吗？</p>
<blockquote>
<p>不能，因为一个对象已经同步了实例方法，线程获取了对象的对象锁。<br>所以只有执行完该方法释放对象锁后才能执行其它同步方法。</p>
</blockquote>
<p>30、什么是线程饿死，什么是活锁？</p>
<blockquote>
<p>线程饿死和活锁虽然不像死锁一样是常见的问题，但是对于并发编程的设计者来说就像一次邂逅一样。<br>当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。<br>JavaAPI 中线程活锁可能发生在以下情形：<br>当所有线程在程序中执行 Object.wait (0)，参数为 0 的 wait 方法。<br>程序将发生活锁直到在相应的对象上有线程调用 Object.notify ()或者 Object.notifyAll ()。<br>当所有线程卡在无限循环中。</p>
</blockquote>
</div><script type="text/javascript" src="/blog/js/share.js?v=0.0.0" async></script><a data-url="http://Invadrxt.github.io/blog/blog/2016/08/07/多线程/" data-id="cizzlid9e000v38fyjr66jvzt" class="article-share-link">分享到</a><div class="tags"><a href="/blog/tags/java基础/">java基础</a></div><div class="post-nav"><a href="/blog/2016/08/07/异常/" class="pre">异常</a><a href="/blog/2016/08/07/Java基础(3)/" class="next">java基础(3)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://Invadrxt.github.io/blog"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/Struts2/" style="font-size: 15px;">Struts2</a> <a href="/blog/tags/java基础/" style="font-size: 15px;">java基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2017/03/07/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/09/06/ Struct2进阶一/">Struts2进阶一</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/27/Struct2入门/">Struts2入门</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/10/关于jdbc-util的封装/">关于jdbc-util的封装</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/10/枚举/">枚举</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/10/反射/">反射</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/10/网络编程/">网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/08/泛型/">泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/08/IO流:/">IO流</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/08/08/IO流/">IO流</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/blog/." rel="nofollow">wxt's blog！.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/blog/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>